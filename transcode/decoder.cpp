#include <polysync/plog/decoder.hpp>
#include <polysync/plog/detector.hpp>
#include <polysync/plog/io.hpp>
#include <polysync/exception.hpp>

#include <algorithm>

std::string print(const std::vector<std::string>& p) { 
    return std::accumulate(p.begin(), p.end(), std::string(), [](auto s, auto f) { return s + "1"; }); 
}

namespace polysync { namespace plog { 

using logging::severity;

// Kick off a decoder with an implict type "log_record" and starting type
// "msg_header".  Continue reading the stream until it ends.
node decoder::operator()(const log_record& record) {

    node result = node::from(record, "log_record");
    plog::tree tree = *result.target<plog::tree>();

    // There is no simple way to detect and enforce that a blob starts with a
    // msg_header.  Hence, we must just assume that every message is well
    // formed and starts with a msg_header.  In that case, might as well do a
    // static parse on msg_header and dynamic parse the rest.
    tree->emplace_back(node::from(decode<msg_header>(), "msg_header"));

    // Burn through the rest of the log record, decoding a sequence of types.
    while (endpos - stream.tellg() > 0) {
        std::string type = detect(tree->back());
        tree->emplace_back(decode_desc(type));
    }
    return result;
}

// Define a set of factory functions that know how to decode specific binary
// types.  They keys are strings from the "type" field of the TOML descriptions.
std::map<std::string, decoder::parser> decoder::parse_map = {
    { "float", [](decoder& r) { return r.decode<float>(); } },
    { ">float32", [](decoder& r) 
        {
            std::uint32_t swap = r.decode<endian::big_uint32_t>().value();
            return *(new ((void *)&swap) float);
        } },
    { "double", [](decoder& r) { return r.decode<double>(); } },
    { "float64", [](decoder& r) { return r.decode<double>(); } },
    { "uint8", [](decoder& r) { return r.decode<std::uint8_t>(); } },
    { "uint16", [](decoder& r) { return r.decode<std::uint16_t>(); } },
    { "uint32", [](decoder& r) { return r.decode<std::uint32_t>(); } },
    { "uint64", [](decoder& r) { return r.decode<std::uint64_t>(); } },
    { "int8", [](decoder& r) { return r.decode<std::int8_t>(); } },
    { "int16", [](decoder& r) { return r.decode<std::int16_t>(); } },
    { "int32", [](decoder& r) { return r.decode<std::int32_t>(); } },
    { "int64", [](decoder& r) { return r.decode<std::int64_t>(); } },
    { ">uint16", [](decoder& r){ return r.decode<endian::big_uint16_t>(); } },
    { ">uint32", [](decoder& r){ return r.decode<endian::big_uint32_t>(); } },
    { ">uint64", [](decoder& r){ return r.decode<endian::big_uint64_t>(); } },
    { ">int16", [](decoder& r){ return r.decode<endian::big_int16_t>(); } },
    { ">int32", [](decoder& r){ return r.decode<endian::big_int32_t>(); } },
    { ">int64", [](decoder& r){ return r.decode<endian::big_int64_t>(); } },
    { "ps_guid", [](decoder& r){ return r.decode<plog::guid>(); } },
    { "ps_timestamp", [](decoder& r) { return r.decode<plog::timestamp>(); } },
    { ">NTP64", [](decoder& r){ return r.decode<endian::big_uint64_t>(); } },
    { "raw", [](decoder& r) 
        { 
            plog::bytes raw;
            std::streampos rem = r.endpos - r.stream.tellg();
            raw.resize(rem);
            r.stream.read((char *)raw.data(), rem);
            return node(raw, "raw");
        }},
};

// Read a field, described by looking up the type by string.  The type strings can
// be compound types described in the TOML description, primitive types known
// by parse_map, or strings generated by boost::hana from compile time structs.
node decoder::decode_desc(const std::string& type) {

    auto parse = parse_map.find(type);
    if (parse != parse_map.end()) 
        return parse->second(*this);

    if (!descriptor::catalog.count(type))
        throw polysync::error("no decoder for type " + type);

    BOOST_LOG_SEV(log, severity::debug2) << "decoding \"" << type << "\"";
    const descriptor::type& desc = descriptor::catalog.at(type);
    return decode(desc);
}

struct branch_builder {
    plog::tree branch;
    const descriptor::field& field;
    decoder* d;

    // Terminal types
    void operator()(std::type_index idx) const {
        if (!descriptor::typemap.count(idx))
            throw polysync::error("no typemap for \"" + to_string(field) + "\"");
        const descriptor::terminal& term = descriptor::typemap.at(idx);
        node a = d->decode_desc(term.name);
        branch->emplace_back(field.name, a);
        BOOST_LOG_SEV(d->log, severity::debug2) << field.name << " = " << a << " (" << term.name << ")";
    }

    // Nested described type
    void operator()(const descriptor::nested& nest) const {
        if (!descriptor::catalog.count(nest.name))
            throw polysync::error("no descriptor for \"" + nest.name + "\"");
        const descriptor::type& desc = descriptor::catalog.at(nest.name);
        node a = d->decode(desc);
        branch->emplace_back(field.name, a);
        BOOST_LOG_SEV(d->log, severity::debug2) << field.name << " = " << a 
            << " (nested \"" << nest.name << "\")";
    }

    // Burn off unused or reserved space
    void operator()(const descriptor::skip& skip) const {
        d->stream.seekg(skip.size, std::ios_base::cur);
        BOOST_LOG_SEV(d->log, severity::debug2) << "skipped " << skip.size << " unused bytes";
    }

    // Array of terminal types
    void operator()(const descriptor::terminal_array& ta) const {
        std::vector<std::uint8_t> array(ta.size);
        for(std::uint8_t& val: array)
           d->decode(val); 
        branch->emplace_back(field.name, array);
        BOOST_LOG_SEV(d->log, severity::debug2) << field.name << " = " << to_string(array);
    }
   
    // Array of described compound types
    void operator()(descriptor::nested_array idx) const {
        std::vector<plog::tree> vec;
        for(size_t i = 0; i < idx.size; ++i) 
            vec.emplace_back(*(d->decode(idx.desc).target<plog::tree>()));
        branch->emplace_back(field.name, vec);
        BOOST_LOG_SEV(d->log, severity::debug2) << field.name << " = " << to_string(vec);
    }

};

plog::node decoder::decode(const descriptor::type& desc) {

    plog::tree child = plog::tree::create();

    std::for_each(desc.begin(), desc.end(), [&](const descriptor::field& field) {
        eggs::variants::apply(branch_builder { child, field, this }, field.type);
        });


            // fields that have been parsed recursively start out as
            // sequence<octet>, but a better, more specific name is discovered
            // during the parse.  If this happened, use the better name.
            // Otherwise, use the original descriptor's name.
            // std::string fname = a.name.empty() ? field.name : a.name;

    return node(desc.name, child);
}


}}  // polysync::plog
